# 전략패턴

- 구상 클래스 (Concrete Class)
    
    모든 메소드가 구현되어 있어 객체를 직접 생성할 수 있는 클래스를 말합니다. 추상 메소드를 포함하지 않으며, 우리가 흔히 사용하는 대부분의 클래스가 이에 해당합니다. 예를 들어, `Car` 클래스에 `drive()` 메소드가 완전히 구현되어 있다면, 이 `Car` 클래스는 구상 클래스입니다.
    
- 인터페이스 (Interface)
    
    **인터페이스**는 추상 메소드와 상수로만 이루어진 **'규격'** 또는 **'계약'**입니다. 객체가 어떤 동작을 수행해야 하는지를 정의하지만, 그 동작을 어떻게 구현할지는 포함하지 않습니다. 특정 클래스가 인터페이스를 **구현(implements)**한다는 것은, 인터페이스에 정의된 모든 메소드를 반드시 구현하겠다는 약속을 의미합니다. 인터페이스는 다중 상속을 허용하여 클래스에 다양한 기능을 부여하는 데 사용됩니다. 예를 들어, `Flyable` 인터페이스에 `fly()` 메소드가 있다면, 비행 기능을 가진 모든 클래스(예: `Airplane`, `Drone`)는 이 인터페이스를 구현하고 `fly()` 메소드를 정의해야 합니다.
    
- 서브클래스 (Subclass)
    
    다른 클래스(슈퍼클래스)의 속성과 메소드를 물려받아 확장하는 클래스입니다. 서브클래스는 슈퍼클래스의 기능을 재사용하고, 필요에 따라 새로운 기능을 추가하거나 기존 메소드를 **재정의(override)**할 수 있습니다. 이를 통해 코드의 재사용성을 높여 계층 구조를 형성합니다. 예를 들어, `Dog`는 `Animal`의 서브클래스입니다.
    
- 컴포지션(Composition)
    
    객체지향 프로그래밍에서 한 객체가 다른 객체를 **포함**하는 관계를 의미합니다. '전체(Whole)'와 '부분(Part)'의 관계로 설명할 수 있으며, 한 객체가 다른 객체의 기능을 사용하기 위해 그 객체를 자신의 멤버 변수로 포함시키는 것입니다. **'HAS-A(헤즈-어)'** 관계로 표현됩니다.
    

---

- 개방-폐쇄 원칙 (OCP)
    
    개방-폐쇄 원칙은 **확장에는 열려 있고(Open for extension), 수정에는 닫혀 있어야(Closed for modification) 한다**는 원칙입니다. 즉, 새로운 기능을 추가할 때 기존의 코드를 수정하지 않고도 새로운 코드를 추가하는 방식으로 기능을 확장할 수 있어야 합니다.
    

객체지향 프로그램에서 기능을 추가할 때 슈퍼클래스에 새로운 메소드를 추가하여 그것을 서브클래스에서 상속받게 한다면 그것이 필요없는 서브클래스들 전체를 수정해야하게 됩니다. 그렇다고 분라하여 인터페이스로 사용한다 하여도 하나를 바꿀때마다 그 행동이 정의되어있는 서로 다른 서브클래스를 전부 찾아서 코드를 전부 고쳐야하겠죠.

슈퍼클래스에 새로운 메소드를 추가할 때, 불필요한 서브클래스들을 수정해야 한다는 문제가 발생합니다. 

- **전략 패턴(Strategy Pattern)**
    
    다양한 행동(알고리즘)을 별도의 클래스로 분리하고(캡슐화) 이를 사용하는 클래스와(클라이언트) 분리하는 방법입니다. 이렇게 하면 새로운 행동이 추가될 때마다 기존 클래스를 수정할 필요 없이 새로운 행동 클래스를 추가하기만 하면 됩니다.(수정과 추가로부터 독립적)
    

### "인터페이스에 맞춰서 프로그래밍 한다”

- **"인터페이스에 맞춰서 프로그래밍 한다"**는 말은 사실 **"상위 형식에 맞춰서 프로그래밍한다"**는 의미입니다. 이는 반드시 자바의 인터페이스를 사용하라는 뜻이 아닌 특정 구현 클래스에 종속되지 않고, 실제 실행 시에 쓰이는 객체가 코드에 고정되지 않도록 **추상 클래스나 인터페이스 같은 상위 형식**을 활용하여 **다형성**을 극대화하는 것을 뜻합니다.

변수를 선언할 때는 아래와같이 추상 클래스나 인터페이스 같은 상위형식으로 선언해야 합니다. (상위 형식에 맞춰서)

![스크린샷 2025-09-17 오후 4.19.27.png](attachment:6a807aa2-5b32-417c-b849-b51231b00333:스크린샷_2025-09-17_오후_4.19.27.png)

```java
Dog d = new Dog();  //Animal확장 구상클래스 
d.bark();
```

- `Dog d = new Dog();` : `Dog`라는 구상 클래스에 맞춰 프로그래밍한 경우입니다.

```java
Animal animal = new Dog();  //인터페이스의 상위 형식에 맞춰서 프로그래밍 
animal.makeSound();
```

- `Animal animal = new Dog();` : `Animal`이라는 상위 형식에 맞춰 프로그래밍한 경우입니다.
이렇게 하면, 실제 어떤 객체를 사용하는지 알 필요 없이 `animal.makeSound()`처럼 메시지를 보낼 수 있어 유연하고 재사용 가능한 코드를 만들 수 있습니다.

```java
// 구체적으로 구현된 객체를 실행시 대입
a = getAnimal();
a.makeSound(); //하위의 어떤 형식인지 알 필요가 없음
```

- 위의 코드에서 `getAnimal()` 메소드는 실행 시점에 `Dog` 객체를 반환할 수도, `Cat` 객체를 반환할 수도 있습니다. 하지만 코드를 사용하는 입장에서는 **`a` 변수가 어떤 구체적인 타입인지를 알 필요가 없습니다.** 그저 `a`가 `Animal` 타입이며 `makeSound()` 메소드를 가지고 있다는 사실만 알면 됩니다. 이처럼 상위 형식에 맞춰 프로그래밍함으로써 코드가 특정 구현에 얽매이지 않고, **변경에 대한 영향을 최소화**할 수 있습니다. 이것이 바로 다형성을 활용하여 유연한 코드를 만드는 핵심입니다.

---

- 숙제
    
    ![1000043516.png](attachment:3e8bb3e5-0f1d-461f-894c-03ae80adfd19:1000043516.png)
    
    1-1. 추상클래스
    
         Character
    
    1-2. 인터페이스
    
         WeaponBehavior
    
    1-3. 클래스
    
    - Queen
    - King
    - Knight
    - Troll
    - KnifeBehavior
    - BowAndArrowBehavior
    - AxeBehavior
    - SwordBehavior
    1. 화살표연결
    - Queen ———▷ Character
    - King ———▷ Character
    - Knight ———▷ Character
    - Troll ———▷ Character
    - KnifeBehavior - - - - ▷ WeaponBehavior
    - BowAndArrowBehavior - - - - ▷ WeaponBehavior
    - AxeBehavior - - - - ▷ WeaponBehavior
    - SwordBehavior - - - - ▷ WeaponBehavior
    - Character <——— WeaponBehavior
    
    3.setWeapon() 메소드 추가하기
    
    - setWeapon() 메소드는 게임 도중에 캐릭터의 무기를 바꾸기 위한 기능입니다. 그러므로 Character 클래스에 추가해야 합니다.
    - 부모 클래스인 Character에 만들어두면 Queen, King 등 모든 자식 캐릭터 클래스가 이 기능을 물려받아 별도의 코드 작성 없이 사용할 수 있을것입니다.
- 느낀점
    
    전략 패턴을 공부하기에 앞서 진행된 간단한 과제에서 객체지향적 프로그래밍이 아닌 절차적 프로그래밍이라는 평가를 받았다. 둘의 차이는 무엇일까에 대해서 생각 해 볼 수 있는 시간이었다.